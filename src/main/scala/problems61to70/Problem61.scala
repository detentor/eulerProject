package problems61to70

import scala.annotation.tailrec
import scala.collection.mutable.ListBuffer

//Triangle, square, pentagonal, hexagonal, heptagonal, 
//and octagonal numbers are all figurate (polygonal) 
//numbers and are generated by the following formulae:
//
//Triangle	 	P3,n=n(n+1)/2	 	1, 3, 6, 10, 15, ...
//Square	 	P4,n=n2	 	1, 4, 9, 16, 25, ...
//Pentagonal	 	P5,n=n(3n-1)/2	 	1, 5, 12, 22, 35, ...
//Hexagonal	 	P6,n=n(2n-1)	 	1, 6, 15, 28, 45, ...
//Heptagonal	 	P7,n=n(5n-3)/2	 	1, 7, 18, 34, 55, ...
//Octagonal	 	P8,n=n(3n-2)	 	1, 8, 21, 40, 65, ...
//The ordered set of three 4-digit numbers: 8128, 2882, 8281, has three interesting properties.
//
//The set is cyclic, in that the last two digits of each number 
//is the first two digits of the next number (including the last number with the first).
//Each polygonal type: triangle (P3,127=8128), 
//square (P4,91=8281), and pentagonal (P5,44=2882), is represented by a different number in the set.
//This is the only set of 4-digit numbers with this property.
//Find the sum of the only ordered set of six cyclic 
//4-digit numbers for which each polygonal type: triangle, square, 
//pentagonal, hexagonal, heptagonal, and octagonal, is represented by a different number in the set.
object Problem61 
{
	def main(args: Array[String]) 
	{
		def triangle(n : Int) = (n * (n + 1)) / 2
		def square(n : Int) = n * n
		def pentagonal(n : Int) = (n * (3 * n - 1))/ 2
		def hexagonal(n : Int) = n * (2 * n - 1)
		def heptagonal(n : Int) = (n * (5 * n - 3)) / 2
		def octagonal(n : Int) = n * (3 * n - 2)
		
//		val sList = List(triangle _, square _, pentagonal _, hexagonal _, heptagonal _, octagonal _)
		val sList = List(triangle _, square _, pentagonal _)
		
		val lowerBound = 999
		val upperBound = 10000
		
		//Encontra todos os números triangulares, quadrados, etc. possíveis
		val numList = sList.map(func => Stream.from(1).dropWhile(k => func(k) < lowerBound)
													  .takeWhile(k => func(k) < upperBound)
													  .map(func))
		
		def isCyclic(x : Int, y : Int) = 
		{
			val str1 = x.toString.splitAt(2)
			val str2 = y.toString.splitAt(2)
			
			str1._1 == str2._2 || str1._2 == str2._1
		}
		
		//Retorna se o princícpio de x é o fim de y
		def isCyclicLeft(x : Int, y : Int) =  x / 100 == y % 100
		
		//Retorna se o fim de x é o começo de y
		def isCyclicRight(x : Int, y : Int) =  x % 100 == y / 100
		
		val firstList = numList.head
		val tailList = numList.tail
		
		def findCyclic(num : Int, leftList : List[Stream[Int]], rightList : List[Stream[Int]]) = 
		{
			//Encontra todos os lugares que este número é prefixo
			val left = for (stream <- leftList; 
							val prefixes = stream.filter(k => isCyclicLeft(num, k)); if prefixes.nonEmpty)
					   yield (stream, prefixes.force)
		
			//Encontra todos os lugares que este número é sufixo
			val right = for (stream <- rightList; 
							val suffixes = stream.filter(k => isCyclicRight(num, k)); if suffixes.nonEmpty)
						yield (stream, suffixes.force)
			
			//CONTINUAR DAQUI!!!!!!!!

									
		}
		
		//Pega-se uma lista qualquer. Obviamente, deverá existir um elemento em ambas as listas, que termine ou começe
		//com os dois primeiros e últimos elementos.
		
		//RESOLVE O PROBLEMA PARA O sList com 3 elementos

//		def isCyclic(x : Int, y : Int) = 
//		{
//			val str1 = x.toString.splitAt(2)
//			val str2 = y.toString.splitAt(2)
//			
//			str1._1 == str2._2 || str1._2 == str2._1
//		}
//		
//		val t = for (triNum <- numList.head; nextNum <- numList.tail.head.filter(k => isCyclic(triNum, k));
//					val nextElems2 = numList.tail.tail.head.filter(k => isCyclic(triNum, k) && isCyclic(nextNum, k))
//					if nextElems2.nonEmpty
//		)
//				yield (triNum, nextNum, nextElems2.force)
//			
//		t.force foreach println
			
	}

}